'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cli = undefined;

var _cucumber = require('cucumber');

var _configuration_builder = require('cucumber/lib/cli/configuration_builder');

var _configuration_builder2 = _interopRequireDefault(_configuration_builder);

var _bluebird = require('bluebird');

var Bluebird = _interopRequireWildcard(_bluebird);

var _ramda = require('ramda');

var R = _interopRequireWildcard(_ramda);

var _runner = require('./runner');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

class Cli extends _cucumber.Cli {
  constructor({ options, cwd, cucumberArgs, stdout }) {
    super({
      cwd, stdout,
      argv: [null, '', ...cucumberArgs]
    });

    this.options = options;
    this.runner = new _runner.Runner(R.pick(['host', 'port', 'command'], options));
    this.eventBroadcaster = new _events2.default();
  }

  getSupportCodeLibrary(supportCodePaths) {
    Object.defineProperty(_cucumber.supportCodeLibraryBuilder.methods, 'runner', {
      enumerable: true,
      value: this.runner
    });

    return super.getSupportCodeLibrary(supportCodePaths);
  }

  getConfiguration() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const builder = new _configuration_builder2.default({ argv: _this.argv, cwd: _this.cwd });

      builder.getUnexpandedFeaturePaths = function () {
        return Bluebird.resolve(_this.options.featurePaths);
      };
      builder.options.require.push(..._this.options.stepPaths);

      const config = yield builder.build();

      if (_this.options.debug) config.formats = [{ type: require.resolve('../formatters/debug-formatter') }];

      if (_this.options.score) config.formats.push({ type: require.resolve('../formatters/score-formatter') });else config.formats.push({ type: require.resolve('../formatters/strip-points-formatter') });

      config.formats = config.formats.filter(function (f) {
        return f.type !== 'none';
      });

      return config;
    })();
  }

  run() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const configuration = yield _this2.getConfiguration();
      const supportCodeLibrary = _this2.getSupportCodeLibrary(configuration.supportCodePaths);
      const cleanup = yield _this2.initializeFormatters({
        supportCodeLibrary,
        eventBroadcaster: _this2.eventBroadcaster,
        formatOptions: configuration.formatOptions,
        formats: configuration.formats
      });

      const testCases = (0, _cucumber.getTestCasesFromFilesystem)({
        cwd: _this2.cwd,
        eventBroadcaster: _this2.eventBroadcaster,
        featurePaths: configuration.featurePaths,
        pickleFilter: new _cucumber.PickleFilter(configuration.pickleFilterOptions)
      });

      const runtime = new _cucumber.Runtime({
        eventBroadcaster: _this2.eventBroadcaster,
        options: configuration.runtimeOptions,
        supportCodeLibrary,
        testCases
      });

      _this2.eventBroadcaster.once('abort', function () {
        configuration.runtimeOptions.dryRun = true;
        runtime.result.success = false;
      });

      try {
        return yield runtime.start();
      } finally {
        yield cleanup();
      }
    })();
  }

  precheck() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const { host, port } = _this3.runner.runConfig;

      try {
        yield _this3.runner.waitForServerUnavailable();
      } catch (err) {
        return {
          ok: false,
          message: `${host}:${port} appears to be in use. Cannot start tests.`
        };
      }

      const output = _this3.runner.start();
      try {
        yield _this3.runner.waitForServerAvailable();
      } catch (err) {
        _this3.runner.forceStop();
        const log = yield output;
        return {
          ok: false,
          message: `Could not connect to ${host}:${port}
Console output:
${log}
`
        };
      } finally {
        _this3.runner.stop();
      }

      return { ok: true };
    })();
  }

  gracefullyExit() {
    this.eventBroadcaster.emit('abort');
    this.runner.stop();
  }

  forceExit() {
    this.eventBroadcaster.emit('abort');
    this.runner.forceStop();
  }
}
exports.Cli = Cli;
//# sourceMappingURL=cli_BASE_17538.js.map