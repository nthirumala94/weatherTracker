{"version":3,"sources":["../../src/steps/response.js"],"names":["Then","statusCode","expect","getResponse","to","eventually","have","property","parseInt","table","expected","single","getResponseBody","deep","equal","path","nested","and","satisfy","r","pathname"],"mappings":";;AAAA;;AACA;;AACA;;AAEA,iCAAkB,CAAC,EAAEA,IAAF,EAAD,KAAc;AAC9BA,OAAK,2CAAL,EAAkD,UAAUC,UAAV,EAAsB;AACtE,WAAOC,OAAO,KAAKC,WAAL,EAAP,EAA2BC,EAA3B,CAA8BC,UAA9B,CAAyCC,IAAzC,CAA8CC,QAA9C,CAAuD,YAAvD,EAAqEC,SAASP,UAAT,EAAqB,EAArB,CAArE,CAAP;AACD,GAFD;;AAIAD,OAAK,yBAAL,EAAgC,UAAUS,KAAV,EAAiB;AAC/C,UAAMC,WAAWC,OAAO,sCAAsBF,KAAtB,CAAP,CAAjB;AACA,WAAOP,OAAO,KAAKU,eAAL,EAAP,EAA+BR,EAA/B,CAAkCC,UAAlC,CAA6CQ,IAA7C,CAAkDC,KAAlD,CAAwDJ,QAAxD,CAAP;AACD,GAHD;;AAKAV,OAAK,qCAAL,EAA4C,UAAUS,KAAV,EAAiB;AAC3D,UAAMC,WAAW,sCAAsBD,KAAtB,CAAjB;AACA,WAAOP,OAAO,KAAKU,eAAL,EAAP,EAA+BR,EAA/B,CAAkCC,UAAlC,CAA6CQ,IAA7C,CAAkDC,KAAlD,CAAwDJ,QAAxD,CAAP;AACD,GAHD;;AAKAV,OAAK,uCAAL,EAA8C,YAAY;AACxD,WAAOE,OAAO,KAAKU,eAAL,EAAP,EAA+BR,EAA/B,CAAkCC,UAAlC,CAA6CQ,IAA7C,CAAkDC,KAAlD,CAAwD,EAAxD,CAAP;AACD,GAFD;;AAIAd,OAAK,8CAAL,EAAqD,UAAUe,IAAV,EAAgB;AACnE,WAAOb,OAAO,KAAKC,WAAL,EAAP,EAA2BC,EAA3B,CAA8BC,UAA9B,CACJC,IADI,CACCU,MADD,CACQT,QADR,CACiB,kBADjB,EAEJU,GAFI,CAEAC,OAFA,CAEQC,KAAK,gBAASA,CAAT,EAAYC,QAAZ,KAAyBL,IAFtC,EAE6C,eAAcA,IAAK,EAFhE,CAAP;AAGD,GAJD;AAKD,CAxBD","file":"response.js","sourcesContent":["import { defineSupportCode } from 'cucumber';\nimport { parse as parseUrl } from 'url';\nimport { readTableValuesAsJson } from '../lib/datatable';\n\ndefineSupportCode(({ Then }) => {\n  Then(/^the response has a status code of (\\d+)$/, function (statusCode) {\n    return expect(this.getResponse()).to.eventually.have.property('statusCode', parseInt(statusCode, 10));\n  });\n\n  Then(/^the response body is:$/, function (table) {\n    const expected = single(readTableValuesAsJson(table));\n    return expect(this.getResponseBody()).to.eventually.deep.equal(expected);\n  });\n\n  Then(/^the response body is an array of:$/, function (table) {\n    const expected = readTableValuesAsJson(table);\n    return expect(this.getResponseBody()).to.eventually.deep.equal(expected);\n  });\n\n  Then(/^the response body is an empty array$/, function () {\n    return expect(this.getResponseBody()).to.eventually.deep.equal([]);\n  });\n\n  Then(/^the Location header has the path \"([^\"]*)\"$/, function (path) {\n    return expect(this.getResponse()).to.eventually\n      .have.nested.property('headers.location')\n      .and.satisfy(r => parseUrl(r).pathname === path, `has path of ${path}`);\n  });\n});\n"]}