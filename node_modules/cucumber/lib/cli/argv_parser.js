'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _commander = require('commander');

var _package = require('../../package.json');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _gherkin = require('gherkin');

var _gherkin2 = _interopRequireDefault(_gherkin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ArgvParser = function () {
  function ArgvParser() {
    (0, _classCallCheck3.default)(this, ArgvParser);
  }

  (0, _createClass3.default)(ArgvParser, null, [{
    key: 'collect',
    value: function collect(val, memo) {
      memo.push(val);
      return memo;
    }
  }, {
    key: 'mergeJson',
    value: function mergeJson(option) {
      return function (str, memo) {
        var val = void 0;
        try {
          val = JSON.parse(str);
        } catch (error) {
          throw new Error(option + ' passed invalid JSON: ' + error.message + ': ' + str);
        }
        if (!_lodash2.default.isPlainObject(val)) {
          throw new Error(option + ' must be passed JSON of an object: ' + str);
        }
        return _lodash2.default.merge(memo, val);
      };
    }
  }, {
    key: 'validateLanguage',
    value: function validateLanguage(val) {
      if (!_lodash2.default.includes(_lodash2.default.keys(_gherkin2.default.DIALECTS), val)) {
        throw new Error('Unsupported ISO 639-1: ' + val);
      }
      return val;
    }
  }, {
    key: 'parse',
    value: function parse(argv) {
      var program = new _commander.Command(_path2.default.basename(argv[1]));

      program.usage('[options] [<DIR|FILE[:LINE]>...]').version(_package.version, '-v, --version').option('-b, --backtrace', 'show full backtrace for errors').option('--compiler <EXTENSION:MODULE>', 'require files with the given EXTENSION after requiring MODULE (repeatable)', ArgvParser.collect, []).option('-d, --dry-run', 'invoke formatters without executing steps').option('--fail-fast', 'abort the run on first failure').option('-f, --format <TYPE[:PATH]>', 'specify the output format, optionally supply PATH to redirect formatter output (repeatable)', ArgvParser.collect, []).option('--format-options <JSON>', 'provide options for formatters (repeatable)', ArgvParser.mergeJson('--format-options'), {}).option('--i18n-keywords <ISO 639-1>', 'list language keywords', ArgvParser.validateLanguage, '').option('--i18n-languages', 'list languages').option('--name <REGEXP>', 'only execute the scenarios with name matching the expression (repeatable)', ArgvParser.collect, []).option('--no-strict', 'succeed even if there are pending steps').option('-p, --profile <NAME>', 'specify the profile to use (repeatable)', ArgvParser.collect, []).option('-r, --require <FILE|DIR>', 'require files before executing features (repeatable)', ArgvParser.collect, []).option('-t, --tags <EXPRESSION>', 'only execute the features or scenarios with tags matching the expression', '').option('--world-parameters <JSON>', 'provide parameters that will be passed to the world constructor (repeatable)', ArgvParser.mergeJson('--world-parameters'), {});

      program.on('--help', function () {
        /* eslint-disable no-console */
        console.log('  For more details please visit https://github.com/cucumber/cucumber-js#cli\n');
        /* eslint-enable no-console */
      });

      program.parse(argv);

      return {
        options: program.opts(),
        args: program.args
      };
    }
  }]);
  return ArgvParser;
}();

exports.default = ArgvParser;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvYXJndl9wYXJzZXIuanMiXSwibmFtZXMiOlsiQXJndlBhcnNlciIsInZhbCIsIm1lbW8iLCJwdXNoIiwib3B0aW9uIiwic3RyIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJpc1BsYWluT2JqZWN0IiwibWVyZ2UiLCJpbmNsdWRlcyIsImtleXMiLCJESUFMRUNUUyIsImFyZ3YiLCJwcm9ncmFtIiwiYmFzZW5hbWUiLCJ1c2FnZSIsInZlcnNpb24iLCJjb2xsZWN0IiwibWVyZ2VKc29uIiwidmFsaWRhdGVMYW5ndWFnZSIsIm9uIiwiY29uc29sZSIsImxvZyIsIm9wdGlvbnMiLCJvcHRzIiwiYXJncyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztJQUVxQkEsVTs7Ozs7Ozs0QkFDSkMsRyxFQUFLQyxJLEVBQU07QUFDeEJBLFdBQUtDLElBQUwsQ0FBVUYsR0FBVjtBQUNBLGFBQU9DLElBQVA7QUFDRDs7OzhCQUVnQkUsTSxFQUFRO0FBQ3ZCLGFBQU8sVUFBU0MsR0FBVCxFQUFjSCxJQUFkLEVBQW9CO0FBQ3pCLFlBQUlELFlBQUo7QUFDQSxZQUFJO0FBQ0ZBLGdCQUFNSyxLQUFLQyxLQUFMLENBQVdGLEdBQVgsQ0FBTjtBQUNELFNBRkQsQ0FFRSxPQUFPRyxLQUFQLEVBQWM7QUFDZCxnQkFBTSxJQUFJQyxLQUFKLENBQ0pMLFNBQVMsd0JBQVQsR0FBb0NJLE1BQU1FLE9BQTFDLEdBQW9ELElBQXBELEdBQTJETCxHQUR2RCxDQUFOO0FBR0Q7QUFDRCxZQUFJLENBQUMsaUJBQUVNLGFBQUYsQ0FBZ0JWLEdBQWhCLENBQUwsRUFBMkI7QUFDekIsZ0JBQU0sSUFBSVEsS0FBSixDQUFVTCxTQUFTLHFDQUFULEdBQWlEQyxHQUEzRCxDQUFOO0FBQ0Q7QUFDRCxlQUFPLGlCQUFFTyxLQUFGLENBQVFWLElBQVIsRUFBY0QsR0FBZCxDQUFQO0FBQ0QsT0FiRDtBQWNEOzs7cUNBRXVCQSxHLEVBQUs7QUFDM0IsVUFBSSxDQUFDLGlCQUFFWSxRQUFGLENBQVcsaUJBQUVDLElBQUYsQ0FBTyxrQkFBUUMsUUFBZixDQUFYLEVBQXFDZCxHQUFyQyxDQUFMLEVBQWdEO0FBQzlDLGNBQU0sSUFBSVEsS0FBSixDQUFVLDRCQUE0QlIsR0FBdEMsQ0FBTjtBQUNEO0FBQ0QsYUFBT0EsR0FBUDtBQUNEOzs7MEJBRVllLEksRUFBTTtBQUNqQixVQUFNQyxVQUFVLHVCQUFZLGVBQUtDLFFBQUwsQ0FBY0YsS0FBSyxDQUFMLENBQWQsQ0FBWixDQUFoQjs7QUFFQUMsY0FDR0UsS0FESCxDQUNTLGtDQURULEVBRUdDLE9BRkgsbUJBRW9CLGVBRnBCLEVBR0doQixNQUhILENBR1UsaUJBSFYsRUFHNkIsZ0NBSDdCLEVBSUdBLE1BSkgsQ0FLSSwrQkFMSixFQU1JLDRFQU5KLEVBT0lKLFdBQVdxQixPQVBmLEVBUUksRUFSSixFQVVHakIsTUFWSCxDQVVVLGVBVlYsRUFVMkIsMkNBVjNCLEVBV0dBLE1BWEgsQ0FXVSxhQVhWLEVBV3lCLGdDQVh6QixFQVlHQSxNQVpILENBYUksNEJBYkosRUFjSSw2RkFkSixFQWVJSixXQUFXcUIsT0FmZixFQWdCSSxFQWhCSixFQWtCR2pCLE1BbEJILENBbUJJLHlCQW5CSixFQW9CSSw2Q0FwQkosRUFxQklKLFdBQVdzQixTQUFYLENBQXFCLGtCQUFyQixDQXJCSixFQXNCSSxFQXRCSixFQXdCR2xCLE1BeEJILENBeUJJLDZCQXpCSixFQTBCSSx3QkExQkosRUEyQklKLFdBQVd1QixnQkEzQmYsRUE0QkksRUE1QkosRUE4QkduQixNQTlCSCxDQThCVSxrQkE5QlYsRUE4QjhCLGdCQTlCOUIsRUErQkdBLE1BL0JILENBZ0NJLGlCQWhDSixFQWlDSSwyRUFqQ0osRUFrQ0lKLFdBQVdxQixPQWxDZixFQW1DSSxFQW5DSixFQXFDR2pCLE1BckNILENBcUNVLGFBckNWLEVBcUN5Qix5Q0FyQ3pCLEVBc0NHQSxNQXRDSCxDQXVDSSxzQkF2Q0osRUF3Q0kseUNBeENKLEVBeUNJSixXQUFXcUIsT0F6Q2YsRUEwQ0ksRUExQ0osRUE0Q0dqQixNQTVDSCxDQTZDSSwwQkE3Q0osRUE4Q0ksc0RBOUNKLEVBK0NJSixXQUFXcUIsT0EvQ2YsRUFnREksRUFoREosRUFrREdqQixNQWxESCxDQW1ESSx5QkFuREosRUFvREksMEVBcERKLEVBcURJLEVBckRKLEVBdURHQSxNQXZESCxDQXdESSwyQkF4REosRUF5REksOEVBekRKLEVBMERJSixXQUFXc0IsU0FBWCxDQUFxQixvQkFBckIsQ0ExREosRUEyREksRUEzREo7O0FBOERBTCxjQUFRTyxFQUFSLENBQVcsUUFBWCxFQUFxQixZQUFNO0FBQ3pCO0FBQ0FDLGdCQUFRQyxHQUFSLENBQ0UsK0VBREY7QUFHQTtBQUNELE9BTkQ7O0FBUUFULGNBQVFWLEtBQVIsQ0FBY1MsSUFBZDs7QUFFQSxhQUFPO0FBQ0xXLGlCQUFTVixRQUFRVyxJQUFSLEVBREo7QUFFTEMsY0FBTVosUUFBUVk7QUFGVCxPQUFQO0FBSUQ7Ozs7O2tCQTdHa0I3QixVIiwiZmlsZSI6ImFyZ3ZfcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ2NvbW1hbmRlcidcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IEdoZXJraW4gZnJvbSAnZ2hlcmtpbidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJndlBhcnNlciB7XG4gIHN0YXRpYyBjb2xsZWN0KHZhbCwgbWVtbykge1xuICAgIG1lbW8ucHVzaCh2YWwpXG4gICAgcmV0dXJuIG1lbW9cbiAgfVxuXG4gIHN0YXRpYyBtZXJnZUpzb24ob3B0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgbWVtbykge1xuICAgICAgbGV0IHZhbFxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsID0gSlNPTi5wYXJzZShzdHIpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgb3B0aW9uICsgJyBwYXNzZWQgaW52YWxpZCBKU09OOiAnICsgZXJyb3IubWVzc2FnZSArICc6ICcgKyBzdHJcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFfLmlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9uICsgJyBtdXN0IGJlIHBhc3NlZCBKU09OIG9mIGFuIG9iamVjdDogJyArIHN0cilcbiAgICAgIH1cbiAgICAgIHJldHVybiBfLm1lcmdlKG1lbW8sIHZhbClcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdmFsaWRhdGVMYW5ndWFnZSh2YWwpIHtcbiAgICBpZiAoIV8uaW5jbHVkZXMoXy5rZXlzKEdoZXJraW4uRElBTEVDVFMpLCB2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIElTTyA2MzktMTogJyArIHZhbClcbiAgICB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgc3RhdGljIHBhcnNlKGFyZ3YpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IENvbW1hbmQocGF0aC5iYXNlbmFtZShhcmd2WzFdKSlcblxuICAgIHByb2dyYW1cbiAgICAgIC51c2FnZSgnW29wdGlvbnNdIFs8RElSfEZJTEVbOkxJTkVdPi4uLl0nKVxuICAgICAgLnZlcnNpb24odmVyc2lvbiwgJy12LCAtLXZlcnNpb24nKVxuICAgICAgLm9wdGlvbignLWIsIC0tYmFja3RyYWNlJywgJ3Nob3cgZnVsbCBiYWNrdHJhY2UgZm9yIGVycm9ycycpXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLS1jb21waWxlciA8RVhURU5TSU9OOk1PRFVMRT4nLFxuICAgICAgICAncmVxdWlyZSBmaWxlcyB3aXRoIHRoZSBnaXZlbiBFWFRFTlNJT04gYWZ0ZXIgcmVxdWlyaW5nIE1PRFVMRSAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLmNvbGxlY3QsXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgICAub3B0aW9uKCctZCwgLS1kcnktcnVuJywgJ2ludm9rZSBmb3JtYXR0ZXJzIHdpdGhvdXQgZXhlY3V0aW5nIHN0ZXBzJylcbiAgICAgIC5vcHRpb24oJy0tZmFpbC1mYXN0JywgJ2Fib3J0IHRoZSBydW4gb24gZmlyc3QgZmFpbHVyZScpXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLWYsIC0tZm9ybWF0IDxUWVBFWzpQQVRIXT4nLFxuICAgICAgICAnc3BlY2lmeSB0aGUgb3V0cHV0IGZvcm1hdCwgb3B0aW9uYWxseSBzdXBwbHkgUEFUSCB0byByZWRpcmVjdCBmb3JtYXR0ZXIgb3V0cHV0IChyZXBlYXRhYmxlKScsXG4gICAgICAgIEFyZ3ZQYXJzZXIuY29sbGVjdCxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctLWZvcm1hdC1vcHRpb25zIDxKU09OPicsXG4gICAgICAgICdwcm92aWRlIG9wdGlvbnMgZm9yIGZvcm1hdHRlcnMgKHJlcGVhdGFibGUpJyxcbiAgICAgICAgQXJndlBhcnNlci5tZXJnZUpzb24oJy0tZm9ybWF0LW9wdGlvbnMnKSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctLWkxOG4ta2V5d29yZHMgPElTTyA2MzktMT4nLFxuICAgICAgICAnbGlzdCBsYW5ndWFnZSBrZXl3b3JkcycsXG4gICAgICAgIEFyZ3ZQYXJzZXIudmFsaWRhdGVMYW5ndWFnZSxcbiAgICAgICAgJydcbiAgICAgIClcbiAgICAgIC5vcHRpb24oJy0taTE4bi1sYW5ndWFnZXMnLCAnbGlzdCBsYW5ndWFnZXMnKVxuICAgICAgLm9wdGlvbihcbiAgICAgICAgJy0tbmFtZSA8UkVHRVhQPicsXG4gICAgICAgICdvbmx5IGV4ZWN1dGUgdGhlIHNjZW5hcmlvcyB3aXRoIG5hbWUgbWF0Y2hpbmcgdGhlIGV4cHJlc3Npb24gKHJlcGVhdGFibGUpJyxcbiAgICAgICAgQXJndlBhcnNlci5jb2xsZWN0LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgICAgLm9wdGlvbignLS1uby1zdHJpY3QnLCAnc3VjY2VlZCBldmVuIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHN0ZXBzJylcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctcCwgLS1wcm9maWxlIDxOQU1FPicsXG4gICAgICAgICdzcGVjaWZ5IHRoZSBwcm9maWxlIHRvIHVzZSAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLmNvbGxlY3QsXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLXIsIC0tcmVxdWlyZSA8RklMRXxESVI+JyxcbiAgICAgICAgJ3JlcXVpcmUgZmlsZXMgYmVmb3JlIGV4ZWN1dGluZyBmZWF0dXJlcyAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLmNvbGxlY3QsXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgICAub3B0aW9uKFxuICAgICAgICAnLXQsIC0tdGFncyA8RVhQUkVTU0lPTj4nLFxuICAgICAgICAnb25seSBleGVjdXRlIHRoZSBmZWF0dXJlcyBvciBzY2VuYXJpb3Mgd2l0aCB0YWdzIG1hdGNoaW5nIHRoZSBleHByZXNzaW9uJyxcbiAgICAgICAgJydcbiAgICAgIClcbiAgICAgIC5vcHRpb24oXG4gICAgICAgICctLXdvcmxkLXBhcmFtZXRlcnMgPEpTT04+JyxcbiAgICAgICAgJ3Byb3ZpZGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3b3JsZCBjb25zdHJ1Y3RvciAocmVwZWF0YWJsZSknLFxuICAgICAgICBBcmd2UGFyc2VyLm1lcmdlSnNvbignLS13b3JsZC1wYXJhbWV0ZXJzJyksXG4gICAgICAgIHt9XG4gICAgICApXG5cbiAgICBwcm9ncmFtLm9uKCctLWhlbHAnLCAoKSA9PiB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJyAgRm9yIG1vcmUgZGV0YWlscyBwbGVhc2UgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL2N1Y3VtYmVyL2N1Y3VtYmVyLWpzI2NsaVxcbidcbiAgICAgIClcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH0pXG5cbiAgICBwcm9ncmFtLnBhcnNlKGFyZ3YpXG5cbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogcHJvZ3JhbS5vcHRzKCksXG4gICAgICBhcmdzOiBwcm9ncmFtLmFyZ3NcbiAgICB9XG4gIH1cbn1cbiJdfQ==